#loopback-testing

**Utilities for testing LoopBack apps**

## overview

The following helpers are designed to generate [mocha] tests against
[LoopBack](http://strongloop.com/loopback) apps.

## about this fork
Developpers coming from rails might be missing usage of fixtures in the [FactoryGirlRails](http://github.com/thoughtbot/factory_girl_rails) way.

This fork is an attempt to implement such a concept, with **belongsTo** and **hasMany** management between fixtures, while keeping compatibility with standard behaviour. 
## install

1. `npm install git://github.com/sacketty/loopback-testing#with/fixtures --save-dev`
2. Assuming you started with a clean template/project generated by `slc loopback`
  1. If you have mocha installed as a global npm module that's great! Simply update `<your_project>/package.json` with:

    ```
    {
      ...
      "scripts": {
        ...
        "test": "mocha"
      }
    }
    ```
  2. Otherwise, you can utilize the mocha library within the `loopback-testing` testing module:

    ```
    {
      ...
      "scripts": {
        ...
        "test": "./node_modules/loopback-testing/node_modules/.bin/mocha"
      }
    }
    ```
3. Run `npm test` to execute any tests under the `test` directory.

## basic usage

Below is a simple LoopBack app.

```js
var loopback = require('loopback');
var app = loopback();
var Product = app.model('product');
Product.attachTo(loopback.memory());
```

Use the `loopback-testing` module to generate `mocha` tests.

```js
var lt = require('loopback-testing');
var assert = require('assert');
var app = require('../server/server.js'); //path to app.js or server.js

describe('/products', function() {
  lt.beforeEach.withApp(app);
  lt.describe.whenCalledRemotely('GET', '/products', function() {
    lt.it.shouldBeAllowed();
    it('should have statusCode 200', function() {
      assert.equal(this.res.statusCode, 200);
    });

    lt.beforeEach.givenModel('product');
    it('should respond with an array of products', function() {
      assert(Array.isArray(this.res.body));
    });
  });
});
```

## building test data

Use TestDataBuilder to build many Model instances in one async call. Specify
only properties relevant to your test, the builder will pre-fill remaining
required properties with sensible defaults.

```js
var TestDataBuilder = require('loopback-testing').TestDataBuilder;
var ref = TestDataBuilder.ref;

// The context object to hold the created models.
// You can use `this` in mocha test instead.
var context = {};

var ref = TestDataBuilder.ref;
new TestDataBuilder()
  .define('application', Application, {
    pushSettings: { stub: { } }
  })
  .define('device', Device, {
     // use the value of application's id
     // the value is resolved at build time
     appId: ref('application.id'),
     deviceType: 'android'
  })
  .define('notification', Notification)
  .buildTo(context, function(err) {
    // test models are available as
    //   context.application
    //   context.device
    //   context.notification
  });
```

## building test data from fixtures

Here is how directory structure looks like:
```lang
+server
	-server.js
+test
	+fixtures
		-users.js
		-devices.js
		-carts.js
		-index.js
	+models
		-devices.test.js
		

```

### fixtures
test/fixtures/users.js:
```js
var factory = {
  bob: {
    name: "Bob"
  },
  alice: {
    name: "Alice"
  }
}
module.exports = factory;
```
test/fixtures/devices.js:

```js
var factory = {
  dev1: {
    type: "phone",
    model: "iPhone6"
  },
  dev2: {
    type: "tablet",
    model: "GalaxyTab2"
  }
}

module.exports = factory;
```
test/fixtures/carts.js:
```js
var factory = {
  usercart: {
    session: "1111122222333333",
    user: {
      fixture: "users",
      value: "bob"
    },
    cart: {
      fixture: "devices",
      items: {
        dev1: 1,
        dev2: 2
      }
    }
  },
  inline: {
    user: {
      fixture: "users",
      value: {
        name: "Alan",
        user: {
          fixture: "books",
          items: {
            b1: {
              data: {
                title: "Begining of the end",
                author: "John Foo"
              },
              quantity: 1
            }
          }
        }
      }
    }
  }

}

module.exports = factory;
```
`factory.inline` is an example of inline fixture creation as it implicitly create corresponding books and users fixtures.


test/fixtures/index.js:
```js
var app = require('../../server/server.js');
var _ = require('underscore');

exports.users = require('./users');
exports.devices = require('./devices');
exports.carts = require('./carts');

exports.map = {
	users: app.models.User,
	devices: app.models.Device,
	carts: app.models.Carts
}
```

**Beware of a gotcha here**

*When using fixture, the node parent should refer to the foreignKey prefix.*

*i.e. carts.js:*

*Cart Model has a 'hasMany' relation to device. So Device has a 'cartId' foreign key. the prefix is then 'cart'. That's why we have a "cart" instead of "devices" in the "usercart" fixture definition.*

*I'll try to find a more intuivie implementation for future release*


### building test data
```js
var TestDataBuilder = require('loopback-testing').TestDataBuilder;
var ref = TestDataBuilder.ref;

// The context object to hold the created models.
// You can use `this` in mocha test instead.
var context = {};

var ref = TestDataBuilder.ref;
var options = {timeout: 100000};
new TestDataBuilder()
  .define('cart', 'carts', 'usercart', options) //options is optional
  .buildTo(context, function(err) {
    // test models are available as
    //   context.cart
    //   context.user
    //   context.devices as an array of devices
  });
```

